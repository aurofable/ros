/* Auto-generated by genmsg_cpp for file /home/james/ros/art/utexas-art-ros-pkg-read-only/stacks/art_vehicle/art_msgs/msg/ArtVehicle.msg */
#ifndef ART_MSGS_MESSAGE_ARTVEHICLE_H
#define ART_MSGS_MESSAGE_ARTVEHICLE_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace art_msgs
{
template <class ContainerAllocator>
struct ArtVehicle_ {
  typedef ArtVehicle_<ContainerAllocator> Type;

  ArtVehicle_()
  {
  }

  ArtVehicle_(const ContainerAllocator& _alloc)
  {
  }

  static const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  frame_id;
  static const float length;
  static const float width;
  static const float height;
  static const float halflength;
  static const float halfwidth;
  static const float halfheight;
  static const float wheelbase;
  static const float front_bumper_px;
  static const float rear_bumper_px;
  static const float front_left_wheel_px;
  static const float front_left_wheel_py;
  static const float front_right_wheel_px;
  static const float front_right_wheel_py;
  static const float rear_left_wheel_px;
  static const float rear_left_wheel_py;
  static const float rear_right_wheel_px;
  static const float rear_right_wheel_py;
  static const float geom_px;
  static const float geom_py;
  static const float geom_pa;
  static const float velodyne_px;
  static const float velodyne_py;
  static const float velodyne_pz;
  static const float velodyne_yaw;
  static const float velodyne_pitch;
  static const float velodyne_roll;
  static const float front_SICK_px;
  static const float front_SICK_py;
  static const float front_SICK_pz;
  static const float front_SICK_roll;
  static const float front_SICK_pitch;
  static const float front_SICK_yaw;
  static const float rear_SICK_px;
  static const float rear_SICK_py;
  static const float rear_SICK_pz;
  static const float rear_SICK_roll;
  static const float rear_SICK_pitch;
  static const float rear_SICK_yaw;
  static const float center_front_camera_px;
  static const float center_front_camera_py;
  static const float center_front_camera_pz;
  static const float center_front_camera_yaw;
  static const float center_front_camera_pitch;
  static const float center_front_camera_roll;
  static const float right_front_camera_px;
  static const float right_front_camera_py;
  static const float right_front_camera_pz;
  static const float right_front_camera_yaw;
  static const float right_front_camera_pitch;
  static const float right_front_camera_roll;
  static const float left_front_camera_px;
  static const float left_front_camera_py;
  static const float left_front_camera_pz;
  static const float left_front_camera_yaw;
  static const float left_front_camera_pitch;
  static const float left_front_camera_roll;
  static const float max_steer_degrees;
  static const float max_steer_radians;
  static const float turn_radius;
  static const float front_outer_wheel_turn_radius;
  static const float front_inner_wheel_turn_radius;
  static const float rear_outer_wheel_turn_radius;
  static const float rear_inner_wheel_turn_radius;

private:
  static const char* __s_getDataType_() { return "art_msgs/ArtVehicle"; }
public:
  ROS_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROS_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "b2e608cff82a26a9766518ef8fbfabf9"; }
public:
  ROS_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROS_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "#  ART vehicle dimensions.\n\
#  $Id$\n\
\n\
#  This class encapsulates constants for the dimensions of the ART\n\
#  autonomous vehicle.  All units are meters or radians, except where\n\
#  noted.  This is not a published message, it defines multi-language\n\
#  constants.\n\
\n\
# ROS frame ID\n\
string frame_id = \"vehicle\"\n\
\n\
float32 length = 4.8                    # overall length\n\
float32 width = 2.12                    # overall width\n\
float32 height = 1.5                    # overall height (TBD)\n\
float32 halflength = 2.4                # length / 2\n\
float32 halfwidth = 1.06                # width / 2\n\
float32 halfheight = 0.75               # height / 2\n\
float32 wheelbase = 2.33918     	# wheelbase\n\
\n\
# egocentric coordinates relative to vehicle origin at center of\n\
# rear axle\n\
float32 front_bumper_px = 3.5   	# (approximately)\n\
float32 rear_bumper_px = -1.3           # front_bumper_px - length\n\
float32 front_left_wheel_px = 2.33918   # wheelbase\n\
float32 front_left_wheel_py = 2.4       # halfwidth\n\
float32 front_right_wheel_px = 2.33918  # wheelbase\n\
float32 front_right_wheel_py = -1.06    #-halfwidth\n\
float32 rear_left_wheel_px = 0.0\n\
float32 rear_left_wheel_py = 1.06       # halfwidth\n\
float32 rear_right_wheel_px = 0.0\n\
float32 rear_right_wheel_py = -1.06     #-halfwidth\n\
\n\
# Player geometry, egocentric pose of robot base (the px really\n\
# does need to be positive for some reason)\n\
float32 geom_px = 1.1                   # front_bumper_px - halflength\n\
float32 geom_py = 0.0\n\
float32 geom_pa = 0.0\n\
\n\
float32 velodyne_px = 0.393             # (approximately)\n\
float32 velodyne_py = 0.278             # (approximately)\n\
float32 velodyne_pz = 2.4               # (calibrated)\n\
#float32 velodyne_yaw=-0.0343           # (before remounting)\n\
float32 velodyne_yaw=-0.02155           # (approximately)\n\
float32 velodyne_pitch=0.016353735091186868 # (calculated)\n\
float32 velodyne_roll=0.0062133721370998124 # (calculated)\n\
\n\
float32 front_SICK_px = 3.178\n\
float32 front_SICK_py= 0.0		# (approximately)\n\
float32 front_SICK_pz = 0.7\n\
float32 front_SICK_roll = 0.0		# (approximately)\n\
float32 front_SICK_pitch = 0.0		# (approximately)\n\
float32 front_SICK_yaw = 0.027	        # (approximately)\n\
\n\
float32 rear_SICK_px = -1.140\n\
float32 rear_SICK_py = 0.0              # (approximately)\n\
float32 rear_SICK_pz = 0.7\n\
float32 rear_SICK_roll = 0.0		# (approximately)\n\
float32 rear_SICK_pitch = 0.0		# (approximately)\n\
float32 rear_SICK_yaw = 3.1415926535897931160  # (approximately PI)\n\
\n\
float32 center_front_camera_px = 0.548     # velodyne_px + 0.155 (approx)\n\
float32 center_front_camera_py = 0.278    # velodyne_py (approx)\n\
float32 center_front_camera_pz = 2.184    # velodyne_pz-0.216 (approx)\n\
float32 center_front_camera_yaw = -0.052  # (measured)\n\
float32 center_front_camera_pitch = 0.025   # (measured)\n\
float32 center_front_camera_roll = 0.0    # (assumed)\n\
\n\
float32 right_front_camera_px = 0.471    # velodyne_px + 0.078 (= 0.155 * cos 60 deg) (approx)\n\
float32 right_front_camera_py = 0.144   # velodyne_py - 0.1342 (= 0.155 + sin 60 deg) (approx)\n\
float32 right_front_camera_pz = 2.184   # velodyne_pz-0.216 (approx)\n\
#float32 right_front_camera_yaw = -0.4974 # (approx -28.5 deg)\n\
float32 right_front_camera_yaw = -1.035 # (measured)\n\
float32 right_front_camera_pitch = 0.022  # (measured)\n\
float32 right_front_camera_roll = 0.0   # (assumed)\n\
\n\
float32 left_front_camera_px = 0.471     # velodyne_px + 0.078 (= 0.155 * cos 60 deg) (approx)\n\
float32 left_front_camera_py = 0.412    # velodyne_py + 0.1342 (= 0.155 * sin 60 deg) (approx)\n\
float32 left_front_camera_pz = 2.184    # velodyne_pz-0.216 (approx)\n\
#float32 left_front_camera_yaw = 0.4974  # (approx +28.5 deg)\n\
float32 left_front_camera_yaw = 0.97  # (measured)\n\
float32 left_front_camera_pitch = -0.017   # (measured)\n\
float32 left_front_camera_roll = 0.0    # (assumed)\n\
\n\
# Compute vehicle turning radius.  This is the distance from the\n\
# center of curvature to the vehicle origin in the middle of the\n\
# rear axle.  The <art/steering.h> comments describe the steering\n\
# geometry model.  Since max_steer_degrees is considerably less\n\
# than 90 degrees, there is no problem taking its tangent.\n\
\n\
float32 max_steer_degrees = 29.0        # maximum steering angle (degrees)\n\
float32 max_steer_radians = 0.5061455   # maximum steering angle (radians)\n\
\n\
# Due to limitations of the ROS message definition format, these\n\
# values needed to be calculated by hand...\n\
\n\
# ArtVehicle.wheelbase / math.tan(ArtVehicle.max_steer_radians)\n\
float32 turn_radius = 4.2199922597674142\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius + ArtVehicle.halfwidth,2))\n\
float32 front_outer_wheel_turn_radius = 5.774952929297676\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius - ArtVehicle.halfwidth,2))\n\
float32 front_inner_wheel_turn_radius = 3.9315790916869484\n\
\n\
# ArtVehicle.turn_radius + ArtVehicle.halfwidth\n\
float32 rear_outer_wheel_turn_radius = 5.2799922597674147\n\
\n\
# ArtVehicle.turn_radius - ArtVehicle.halfwidth\n\
float32 rear_inner_wheel_turn_radius = 3.1599922597674142\n\
\n\
# float32 front_outer_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+powf(turn_radius+halfwidth,2))\n\
#  \n\
# float32 front_inner_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
#\n\
# float32 rear_outer_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius+halfwidth,2))\n\
#\n\
# float32 rear_inner_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
\n\
"; }
public:
  ROS_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    return size;
  }

  typedef boost::shared_ptr< ::art_msgs::ArtVehicle_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::art_msgs::ArtVehicle_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct ArtVehicle
typedef  ::art_msgs::ArtVehicle_<std::allocator<void> > ArtVehicle;

typedef boost::shared_ptr< ::art_msgs::ArtVehicle> ArtVehiclePtr;
typedef boost::shared_ptr< ::art_msgs::ArtVehicle const> ArtVehicleConstPtr;

template<typename ContainerAllocator> const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  ArtVehicle_<ContainerAllocator>::frame_id = "\"vehicle\"";
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::length = 4.8;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::width = 2.12;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::height = 1.5;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::halflength = 2.4;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::halfwidth = 1.06;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::halfheight = 0.75;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::wheelbase = 2.33918;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_bumper_px = 3.5;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_bumper_px = -1.3;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_left_wheel_px = 2.33918;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_left_wheel_py = 2.4;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_right_wheel_px = 2.33918;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_right_wheel_py = -1.06;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_left_wheel_px = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_left_wheel_py = 1.06;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_right_wheel_px = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_right_wheel_py = -1.06;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::geom_px = 1.1;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::geom_py = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::geom_pa = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::velodyne_px = 0.393;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::velodyne_py = 0.278;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::velodyne_pz = 2.4;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::velodyne_yaw = -0.02155;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::velodyne_pitch = 0.0163537350912;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::velodyne_roll = 0.0062133721371;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_SICK_px = 3.178;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_SICK_py = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_SICK_pz = 0.7;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_SICK_roll = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_SICK_pitch = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_SICK_yaw = 0.027;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_SICK_px = -1.14;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_SICK_py = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_SICK_pz = 0.7;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_SICK_roll = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_SICK_pitch = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_SICK_yaw = 3.14159265359;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::center_front_camera_px = 0.548;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::center_front_camera_py = 0.278;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::center_front_camera_pz = 2.184;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::center_front_camera_yaw = -0.052;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::center_front_camera_pitch = 0.025;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::center_front_camera_roll = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::right_front_camera_px = 0.471;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::right_front_camera_py = 0.144;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::right_front_camera_pz = 2.184;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::right_front_camera_yaw = -1.035;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::right_front_camera_pitch = 0.022;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::right_front_camera_roll = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::left_front_camera_px = 0.471;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::left_front_camera_py = 0.412;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::left_front_camera_pz = 2.184;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::left_front_camera_yaw = 0.97;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::left_front_camera_pitch = -0.017;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::left_front_camera_roll = 0.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::max_steer_degrees = 29.0;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::max_steer_radians = 0.5061455;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::turn_radius = 4.21999225977;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_outer_wheel_turn_radius = 5.7749529293;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::front_inner_wheel_turn_radius = 3.93157909169;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_outer_wheel_turn_radius = 5.27999225977;
template<typename ContainerAllocator> const float ArtVehicle_<ContainerAllocator>::rear_inner_wheel_turn_radius = 3.15999225977;

template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::art_msgs::ArtVehicle_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::art_msgs::ArtVehicle_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace art_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::art_msgs::ArtVehicle_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::art_msgs::ArtVehicle_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::art_msgs::ArtVehicle_<ContainerAllocator> > {
  static const char* value() 
  {
    return "b2e608cff82a26a9766518ef8fbfabf9";
  }

  static const char* value(const  ::art_msgs::ArtVehicle_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xb2e608cff82a26a9ULL;
  static const uint64_t static_value2 = 0x766518ef8fbfabf9ULL;
};

template<class ContainerAllocator>
struct DataType< ::art_msgs::ArtVehicle_<ContainerAllocator> > {
  static const char* value() 
  {
    return "art_msgs/ArtVehicle";
  }

  static const char* value(const  ::art_msgs::ArtVehicle_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::art_msgs::ArtVehicle_<ContainerAllocator> > {
  static const char* value() 
  {
    return "#  ART vehicle dimensions.\n\
#  $Id$\n\
\n\
#  This class encapsulates constants for the dimensions of the ART\n\
#  autonomous vehicle.  All units are meters or radians, except where\n\
#  noted.  This is not a published message, it defines multi-language\n\
#  constants.\n\
\n\
# ROS frame ID\n\
string frame_id = \"vehicle\"\n\
\n\
float32 length = 4.8                    # overall length\n\
float32 width = 2.12                    # overall width\n\
float32 height = 1.5                    # overall height (TBD)\n\
float32 halflength = 2.4                # length / 2\n\
float32 halfwidth = 1.06                # width / 2\n\
float32 halfheight = 0.75               # height / 2\n\
float32 wheelbase = 2.33918     	# wheelbase\n\
\n\
# egocentric coordinates relative to vehicle origin at center of\n\
# rear axle\n\
float32 front_bumper_px = 3.5   	# (approximately)\n\
float32 rear_bumper_px = -1.3           # front_bumper_px - length\n\
float32 front_left_wheel_px = 2.33918   # wheelbase\n\
float32 front_left_wheel_py = 2.4       # halfwidth\n\
float32 front_right_wheel_px = 2.33918  # wheelbase\n\
float32 front_right_wheel_py = -1.06    #-halfwidth\n\
float32 rear_left_wheel_px = 0.0\n\
float32 rear_left_wheel_py = 1.06       # halfwidth\n\
float32 rear_right_wheel_px = 0.0\n\
float32 rear_right_wheel_py = -1.06     #-halfwidth\n\
\n\
# Player geometry, egocentric pose of robot base (the px really\n\
# does need to be positive for some reason)\n\
float32 geom_px = 1.1                   # front_bumper_px - halflength\n\
float32 geom_py = 0.0\n\
float32 geom_pa = 0.0\n\
\n\
float32 velodyne_px = 0.393             # (approximately)\n\
float32 velodyne_py = 0.278             # (approximately)\n\
float32 velodyne_pz = 2.4               # (calibrated)\n\
#float32 velodyne_yaw=-0.0343           # (before remounting)\n\
float32 velodyne_yaw=-0.02155           # (approximately)\n\
float32 velodyne_pitch=0.016353735091186868 # (calculated)\n\
float32 velodyne_roll=0.0062133721370998124 # (calculated)\n\
\n\
float32 front_SICK_px = 3.178\n\
float32 front_SICK_py= 0.0		# (approximately)\n\
float32 front_SICK_pz = 0.7\n\
float32 front_SICK_roll = 0.0		# (approximately)\n\
float32 front_SICK_pitch = 0.0		# (approximately)\n\
float32 front_SICK_yaw = 0.027	        # (approximately)\n\
\n\
float32 rear_SICK_px = -1.140\n\
float32 rear_SICK_py = 0.0              # (approximately)\n\
float32 rear_SICK_pz = 0.7\n\
float32 rear_SICK_roll = 0.0		# (approximately)\n\
float32 rear_SICK_pitch = 0.0		# (approximately)\n\
float32 rear_SICK_yaw = 3.1415926535897931160  # (approximately PI)\n\
\n\
float32 center_front_camera_px = 0.548     # velodyne_px + 0.155 (approx)\n\
float32 center_front_camera_py = 0.278    # velodyne_py (approx)\n\
float32 center_front_camera_pz = 2.184    # velodyne_pz-0.216 (approx)\n\
float32 center_front_camera_yaw = -0.052  # (measured)\n\
float32 center_front_camera_pitch = 0.025   # (measured)\n\
float32 center_front_camera_roll = 0.0    # (assumed)\n\
\n\
float32 right_front_camera_px = 0.471    # velodyne_px + 0.078 (= 0.155 * cos 60 deg) (approx)\n\
float32 right_front_camera_py = 0.144   # velodyne_py - 0.1342 (= 0.155 + sin 60 deg) (approx)\n\
float32 right_front_camera_pz = 2.184   # velodyne_pz-0.216 (approx)\n\
#float32 right_front_camera_yaw = -0.4974 # (approx -28.5 deg)\n\
float32 right_front_camera_yaw = -1.035 # (measured)\n\
float32 right_front_camera_pitch = 0.022  # (measured)\n\
float32 right_front_camera_roll = 0.0   # (assumed)\n\
\n\
float32 left_front_camera_px = 0.471     # velodyne_px + 0.078 (= 0.155 * cos 60 deg) (approx)\n\
float32 left_front_camera_py = 0.412    # velodyne_py + 0.1342 (= 0.155 * sin 60 deg) (approx)\n\
float32 left_front_camera_pz = 2.184    # velodyne_pz-0.216 (approx)\n\
#float32 left_front_camera_yaw = 0.4974  # (approx +28.5 deg)\n\
float32 left_front_camera_yaw = 0.97  # (measured)\n\
float32 left_front_camera_pitch = -0.017   # (measured)\n\
float32 left_front_camera_roll = 0.0    # (assumed)\n\
\n\
# Compute vehicle turning radius.  This is the distance from the\n\
# center of curvature to the vehicle origin in the middle of the\n\
# rear axle.  The <art/steering.h> comments describe the steering\n\
# geometry model.  Since max_steer_degrees is considerably less\n\
# than 90 degrees, there is no problem taking its tangent.\n\
\n\
float32 max_steer_degrees = 29.0        # maximum steering angle (degrees)\n\
float32 max_steer_radians = 0.5061455   # maximum steering angle (radians)\n\
\n\
# Due to limitations of the ROS message definition format, these\n\
# values needed to be calculated by hand...\n\
\n\
# ArtVehicle.wheelbase / math.tan(ArtVehicle.max_steer_radians)\n\
float32 turn_radius = 4.2199922597674142\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius + ArtVehicle.halfwidth,2))\n\
float32 front_outer_wheel_turn_radius = 5.774952929297676\n\
\n\
# math.sqrt(math.pow(ArtVehicle.wheelbase,2)\n\
#           + math.pow(ArtVehicle.turn_radius - ArtVehicle.halfwidth,2))\n\
float32 front_inner_wheel_turn_radius = 3.9315790916869484\n\
\n\
# ArtVehicle.turn_radius + ArtVehicle.halfwidth\n\
float32 rear_outer_wheel_turn_radius = 5.2799922597674147\n\
\n\
# ArtVehicle.turn_radius - ArtVehicle.halfwidth\n\
float32 rear_inner_wheel_turn_radius = 3.1599922597674142\n\
\n\
# float32 front_outer_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+powf(turn_radius+halfwidth,2))\n\
#  \n\
# float32 front_inner_bumper_turn_radius = sqrtf(powf(front_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
#\n\
# float32 rear_outer_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius+halfwidth,2))\n\
#\n\
# float32 rear_inner_bumper_turn_radius = sqrtf(powf(rear_bumper_px,2)+ powf(turn_radius-halfwidth,2))\n\
\n\
";
  }

  static const char* value(const  ::art_msgs::ArtVehicle_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::art_msgs::ArtVehicle_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::art_msgs::ArtVehicle_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct ArtVehicle_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::art_msgs::ArtVehicle_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::art_msgs::ArtVehicle_<ContainerAllocator> & v) 
  {
  }
};


} // namespace message_operations
} // namespace ros

#endif // ART_MSGS_MESSAGE_ARTVEHICLE_H

